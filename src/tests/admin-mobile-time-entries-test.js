// Teste de aprova√ß√£o de horas por administrador na API Mobile
const axios = require('axios');

// Configura√ß√£o da base URL para testes
const BASE_URL = process.env.TEST_API_BASE_URL || 'http://localhost:3000/api';

// Tempo de espera entre tentativas (em ms)
const RETRY_DELAY = 2000;

// Dados para teste
const ADMIN_USER = {
  email: 'admin_mobile_test@teste.com',
  password: 'senha123'
};

const EMPLOYEE_USER = {
  email: 'funcionario_mobile_test@teste.com',
  password: 'senha123'
};

// Credenciais para manager (usando as credenciais reais agora)
const MANAGER_USER = {
  email: 'manager_mobile_test@teste.com',
  password: 'senha123'
};

// Fun√ß√£o para dormir
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

// Fun√ß√£o para obter a data atual formatada (YYYY-MM-DD)
const getTodayFormatted = () => {
  const today = new Date();
  return today.toISOString().split('T')[0]; // formato YYYY-MM-DD
};

// Fun√ß√£o para obter uma data no passado (ex: m√™s anterior)
const getPastDateFormatted = (monthsToSubtract = 1) => {
  const today = new Date();
  today.setMonth(today.getMonth() - monthsToSubtract);
  return today.toISOString().split('T')[0]; // formato YYYY-MM-DD
};

// Fun√ß√£o principal de teste
async function testarAprovacaoHorasAdmin() {
  console.log('üöÄ Iniciando teste de aprova√ß√£o de horas por administrador na API Mobile');
  
  let adminToken = null;
  let employeeToken = null;
  let adminUser = null;
  let employeeUser = null;
  let registro1 = null;
  let registro2 = null;

  try {
    // Parte 1: Login como admin
    console.log('\nüë§ Autenticando como administrador...');
    try {
      const responseAdmin = await axios.post(`${BASE_URL}/mobile-auth`, ADMIN_USER);
      adminToken = responseAdmin.data.token;
      adminUser = responseAdmin.data.user;
      console.log(`‚úÖ Admin autenticado: ${adminUser.name} (${adminUser.role})`);
    } catch (error) {
      console.log('‚ùå Falha ao autenticar como admin:', error.response ? error.response.data : error.message);
      return;
    }

    // Parte 2: Login como funcion√°rio
    console.log('\nüë§ Autenticando como funcion√°rio...');
    try {
      const responseEmployee = await axios.post(`${BASE_URL}/mobile-auth`, EMPLOYEE_USER);
      employeeToken = responseEmployee.data.token;
      employeeUser = responseEmployee.data.user;
      console.log(`‚úÖ Funcion√°rio autenticado: ${employeeUser.name} (${employeeUser.role})`);
    } catch (error) {
      console.log('‚ùå Falha ao autenticar como funcion√°rio:', error.response ? error.response.data : error.message);
      return;
    }

    // Verificar se admin e employee est√£o na mesma empresa
    if (adminUser.companyId !== employeeUser.companyId) {
      console.log('‚ö†Ô∏è Admin e funcion√°rio n√£o est√£o na mesma empresa!');
      return;
    } else {
      console.log('‚úÖ Admin e funcion√°rio est√£o na mesma empresa.');
    }

    const dataFormatada = getTodayFormatted();
    console.log(`üìÖ Data do teste: ${dataFormatada}`);

    console.log('\nüßπ Removendo registros existentes para evitar conflitos (como Admin)...');
    try {
      const existingRecordsResponse = await axios.get(
        `${BASE_URL}/mobile-time-entries`,
        { 
          headers: { Authorization: `Bearer ${adminToken}` }, // Usar adminToken para listar todos da empresa
          params: { 
            // Vamos listar todos da empresa para a data, sem filtrar por employeeUser.id ainda
            // Se filtrarmos por employeeUser.id, o admin s√≥ ver√° os do funcion√°rio.
            // Para limpar geral, melhor n√£o especificar userId aqui.
            startDate: dataFormatada,
            endDate: dataFormatada,
            companyId: adminUser.companyId // Garantir que estamos na empresa certa, se a API suportar
          }
        }
      );
      
      const existingRecords = existingRecordsResponse.data.timeEntries.filter(entry => entry.user.id === employeeUser.id);
      console.log(`Encontrados ${existingRecords.length} registros DO FUNCION√ÅRIO ESPEC√çFICO para a data ${dataFormatada} para limpeza.`);
      
      for (const record of existingRecords) {
        try {
          console.log(`  Attempting to delete record ID: ${record.id} belonging to user ${record.user.id} as ADMIN ${adminUser.id}`);
          await axios.delete(
            `${BASE_URL}/mobile-time-entries/${record.id}`, 
            { headers: { Authorization: `Bearer ${adminToken}` } } // Usar adminToken para deletar
          );
          console.log(`  ‚úÖ Registro ${record.id} (do funcion√°rio ${employeeUser.name}) removido pelo admin`);
        } catch (errorDelete) {
          console.log(`  ‚ö†Ô∏è N√£o foi poss√≠vel remover o registro ${record.id} (do func.): ${errorDelete.message}. Status: ${errorDelete.response?.status}`);
          if(errorDelete.response?.data?.error === 'Este registro j√° est√° associado a um pagamento e n√£o pode ser exclu√≠do'){
            console.log(`  INFO: Registro ${record.id} n√£o pode ser exclu√≠do pois est√° associado a um pagamento.`);
          } else if (errorDelete.response?.status === 403 && adminUser.id === record.user.id) {
            console.log(` INFO: Admin n√£o pode deletar seu pr√≥prio registro por esta rota (se aplic√°vel), ou outra restri√ß√£o 403.`);
          }
        }
      }
    } catch (errorList) {
      console.log('‚ö†Ô∏è Erro ao listar/remover registros existentes (como Admin):', errorList.message);
    }

    // Parte 4: Criar registros de horas como funcion√°rio com uma diferen√ßa de 3 horas entre eles
    console.log('\n‚è±Ô∏è Criando registros de horas como funcion√°rio...');
    
    // Registro 1: Manh√£ (8h-9h30)
    try {
      const dadosRegistro1 = {
        date: dataFormatada,
        startTime: `${dataFormatada}T08:00:00`,
        endTime: `${dataFormatada}T09:30:00`,
        observation: `Registro 1 - manh√£ (teste admin) ${Date.now()}`,
        project: 'Projeto Teste Admin'
      };
      
      console.log('Enviando dados para criar registro 1:', dadosRegistro1);
      
      const response1 = await axios.post(
        `${BASE_URL}/mobile-time-entries`, 
        dadosRegistro1, 
        { headers: { Authorization: `Bearer ${employeeToken}` } }
      );
      
      registro1 = response1.data.timeEntry;
      console.log(`‚úÖ Registro 1 criado com ID: ${registro1.id}`);
    } catch (error) {
      console.log('‚ùå Falha ao criar registro 1:', error.message);
      if (error.response && error.response.data) {
        console.log('Resposta:', error.response.data);
      }
    }
    
    // Registro 2: Tarde (13h-15h)
    try {
      const dadosRegistro2 = {
        date: dataFormatada,
        startTime: `${dataFormatada}T13:00:00`,
        endTime: `${dataFormatada}T15:00:00`,
        observation: `Registro 2 - tarde (teste admin) ${Date.now()}`,
        project: 'Projeto Teste Admin'
      };
      
      console.log('Enviando dados para criar registro 2:', dadosRegistro2);
      
      const response2 = await axios.post(
        `${BASE_URL}/mobile-time-entries`, 
        dadosRegistro2, 
        { headers: { Authorization: `Bearer ${employeeToken}` } }
      );
      
      registro2 = response2.data.timeEntry;
      console.log(`‚úÖ Registro 2 criado com ID: ${registro2.id}`);
    } catch (error) {
      console.log('‚ùå Falha ao criar registro 2:', error.message);
      if (error.response && error.response.data) {
        console.log('Resposta:', error.response.data);
      }
    }

    // Aguardar um momento para os registros serem processados
    console.log('\n‚è≥ Aguardando 2 segundos para os registros serem processados...');
    await sleep(RETRY_DELAY);

    // Parte 5: Verificar se o admin consegue ver os registros do funcion√°rio
    console.log('\nüîç Verificando se admin visualiza registros do funcion√°rio...');
    
    try {
      console.log(`Consultando registros para a data ${dataFormatada}`);
      
      const response = await axios.get(
        `${BASE_URL}/mobile-time-entries`,
        { 
          headers: { Authorization: `Bearer ${adminToken}` },
          params: { 
            startDate: dataFormatada,
            endDate: dataFormatada
          }
        }
      );
      
      console.log(`üìä Total de registros retornados: ${response.data.timeEntries.length}`);
      
      // Mostrar detalhes de todos os registros encontrados para diagn√≥stico
      console.log('üìú Lista completa de registros retornados:');
      response.data.timeEntries.forEach((entry, index) => {
        console.log(`  [${index + 1}] ID: ${entry.id}, Data: ${entry.date}, Hor√°rio: ${entry.startTime.substring(11, 16)}-${entry.endTime.substring(11, 16)}, Usu√°rio: ${entry.user?.name || 'N/A'}, Obs: "${entry.observation?.substring(0, 30)}${entry.observation?.length > 30 ? '...' : ''}"`);
      });
      
      // Verificar se os IDs dos registros criados est√£o na lista retornada
      const registrosEncontrados = response.data.timeEntries.filter(
        entry => {
          let encontrado = false;
          
          if (registro1 && entry.id === registro1.id) {
            encontrado = true;
            console.log(`‚úÖ Encontrado registro 1: ${entry.id}, observa√ß√£o: "${entry.observation}"`);
          } else if (registro2 && entry.id === registro2.id) {
            encontrado = true;
            console.log(`‚úÖ Encontrado registro 2: ${entry.id}, observa√ß√£o: "${entry.observation}"`);
          }
          
          return encontrado;
        }
      );
      
      if (registrosEncontrados.length === 2 || (registro1 === null && registro2 !== null && registrosEncontrados.length === 1)) {
        console.log('‚úÖ Admin consegue visualizar os registros do funcion√°rio!');
      } else if (registrosEncontrados.length > 0) {
        console.log(`‚ö†Ô∏è Admin visualiza apenas ${registrosEncontrados.length} dos registros esperados`);
      } else {
        console.log('‚ùå ERRO: Admin n√£o est√° visualizando os registros do funcion√°rio');
        console.log('‚ö†Ô∏è PROBLEMA IDENTIFICADO: A API mobile n√£o est√° permitindo que administradores vejam registros de seus funcion√°rios');
      }

      console.log('\nüìã Detalhes do filtro aplicado na API:');
      console.log(response.data.appliedFilters);
      
    } catch (error) {
      console.log('‚ùå Falha ao obter registros como admin:', error.message);
      if (error.response) {
        console.log('Resposta:', error.response.data);
      }
    }

    // Parte 6: Testar aprova√ß√£o de um registro
    if (registro1) {
      console.log('\nüëç Testando aprova√ß√£o de registro...');
      
      try {
        // Verificar se o endpoint de aprova√ß√£o existe
        const approveUrl = `${BASE_URL}/mobile-time-entries/${registro1.id}/approve`;
        const approveData = { approved: true };
        
        const approveResponse = await axios.put(
          approveUrl,
          approveData,
          { headers: { Authorization: `Bearer ${adminToken}` } }
        );
        
        console.log('‚úÖ Aprova√ß√£o de registro funcionou!');
        console.log('üìÑ Resposta:', approveResponse.data);
      } catch (error) {
        console.log('‚ùå ERRO: Falha ao aprovar registro', error.message);
        console.log('‚ö†Ô∏è PROBLEMA IDENTIFICADO: Endpoint /mobile-time-entries/{id}/approve pode n√£o existir');
        
        if (error.response) {
          console.log('Status:', error.response.status);
          console.log('Resposta:', error.response.data);
        }
      }
    }

    // Parte 7: Testar rejei√ß√£o de um registro
    if (registro2) {
      console.log('\nüëé Testando rejei√ß√£o de registro...');
      
      try {
        // Verificar se o endpoint de aprova√ß√£o existe
        const rejectUrl = `${BASE_URL}/mobile-time-entries/${registro2.id}/approve`;
        const rejectData = { 
          approved: false,
          rejectionReason: 'Registro rejeitado pelo teste automatizado'
        };
        
        const rejectResponse = await axios.put(
          rejectUrl,
          rejectData,
          { headers: { Authorization: `Bearer ${adminToken}` } }
        );
        
        console.log('‚úÖ Rejei√ß√£o de registro funcionou!');
        console.log('üìÑ Resposta:', rejectResponse.data);
      } catch (error) {
        console.log('‚ùå ERRO: Falha ao rejeitar registro', error.message);
        console.log('‚ö†Ô∏è PROBLEMA IDENTIFICADO: Endpoint /mobile-time-entries/{id}/approve pode n√£o existir');
        
        if (error.response) {
          console.log('Status:', error.response.status);
          console.log('Resposta:', error.response.data);
        }
      }
    }

    // ADICIONAR CHAMADA AO NOVO TESTE ISPAID AQUI DENTRO, SE FIZER SENTIDO TER OS DADOS
    // OU CHAMAR SEPARADAMENTE ABAIXO

  } catch (error) {
    console.log('‚ùå ERRO: Falha ao executar o teste:', error.message);
    if (error.response) {
      console.log('Resposta:', error.response.data);
    }
  }
}

// TESTE PARA A FUNCIONALIDADE includeOwnEntries
async function testManagerOwnTimeEntries(managerToken, managerUser) {
  console.log('\nüîç Testando: Manager visualizando seus pr√≥prios registros de horas (GET /mobile-time-entries?includeOwnEntries=true)');
  if (!managerToken || !managerUser) {
    console.log('‚ö†Ô∏è Manager n√£o autenticado. Pulando teste.');
    return;
  }

  const dataFormatada = getTodayFormatted();
  console.log(`üìÖ Data do teste para manager: ${dataFormatada}`);
  
  // Criar um registro de horas para o manager testar
  try {
    console.log('\n‚è±Ô∏è Criando um registro de horas para o manager...');
    const dadosRegistroManager = {
      date: dataFormatada,
      startTime: `${dataFormatada}T10:00:00`,
      endTime: `${dataFormatada}T11:30:00`,
      observation: `Registro do manager (teste) ${Date.now()}`,
      project: 'Projeto Teste Manager'
    };
    
    console.log('Enviando dados para criar registro do manager:', dadosRegistroManager);
    
    const responseManagerEntry = await axios.post(
      `${BASE_URL}/mobile-time-entries`, 
      dadosRegistroManager, 
      { headers: { Authorization: `Bearer ${managerToken}` } }
    );
    
    const registroManager = responseManagerEntry.data.timeEntry;
    console.log(`‚úÖ Registro do manager criado com ID: ${registroManager.id}`);
    
    // Aguardar um momento para o registro ser processado
    console.log('\n‚è≥ Aguardando 2 segundos para o registro ser processado...');
    await sleep(RETRY_DELAY);

    // Teste 1: Buscar apenas os pr√≥prios registros (Minhas Horas)
    console.log('\nüîç Teste 1: Buscar apenas os pr√≥prios registros do manager');
    const ownEntriesResponse = await axios.get(
      `${BASE_URL}/mobile-time-entries?includeOwnEntries=true&userId=${managerUser.id}`,
      { headers: { Authorization: `Bearer ${managerToken}` } }
    );

    // Verificar se retornou registros e se todos pertencem ao manager
    const ownEntries = ownEntriesResponse.data.timeEntries || [];
    if (ownEntries.length > 0) {
      const allBelongToManager = ownEntries.every(entry => entry.user?.id === managerUser.id);
      if (allBelongToManager) {
        console.log(`‚úÖ Manager conseguiu visualizar ${ownEntries.length} registro(s) pr√≥prio(s) com sucesso.`);
      } else {
        console.error('‚ùå Alguns registros retornados n√£o pertencem ao manager.');
      }
    } else {
      console.log('‚ÑπÔ∏è Nenhum registro pr√≥prio encontrado para o manager.');
    }

    // Teste 2: Buscar todos os registros incluindo os pr√≥prios
    console.log('\nüîç Teste 2: Buscar todos os registros incluindo os pr√≥prios');
    const allEntriesResponse = await axios.get(
      `${BASE_URL}/mobile-time-entries?includeOwnEntries=true`,
      { headers: { Authorization: `Bearer ${managerToken}` } }
    );

    // Verificar se retornou registros e se existem registros do manager
    const allEntries = allEntriesResponse.data.timeEntries || [];
    if (allEntries.length > 0) {
      const hasManagerEntries = allEntries.some(entry => entry.user?.id === managerUser.id);
      if (hasManagerEntries) {
        console.log(`‚úÖ Manager conseguiu visualizar registros de equipe (${allEntries.length} total) incluindo os pr√≥prios.`);
      } else {
        console.log('‚ÑπÔ∏è Manager visualizou registros da equipe, mas n√£o possui registros pr√≥prios.');
      }
    } else {
      console.log('‚ÑπÔ∏è Nenhum registro encontrado para a equipe do manager.');
    }

    // Teste 3: Tentativa de aprova√ß√£o de registro pr√≥prio (deve falhar)
    console.log('\nüîç Teste 3: Tentar aprovar o pr√≥prio registro (deve falhar)');
    if (registroManager && registroManager.id) {
      try {
        await axios.put(
          `${BASE_URL}/mobile-time-entries/${registroManager.id}/approve`,
          { approved: true },
          { headers: { Authorization: `Bearer ${managerToken}` } }
        );
        console.error('‚ùå Manager conseguiu aprovar seu pr√≥prio registro, o que n√£o deveria ser permitido.');
      } catch (approvalError) {
        if (approvalError.response && approvalError.response.status === 403) {
          console.log('‚úÖ Corretamente impedido de aprovar seu pr√≥prio registro de horas.');
          console.log('üìÑ Resposta:', approvalError.response.data);
        } else {
          console.error('‚ùå Erro inesperado ao tentar aprovar registro pr√≥prio:', 
            approvalError.response ? approvalError.response.data : approvalError.message);
        }
      }
    } else {
      console.log('‚ÑπÔ∏è Sem registros pr√≥prios para testar a restri√ß√£o de auto-aprova√ß√£o.');
    }

    // Limpeza - tentar excluir o registro criado
    console.log('\nüßπ Limpando registro de teste do manager...');
    try {
      await axios.delete(
        `${BASE_URL}/mobile-time-entries/${registroManager.id}`, 
        { headers: { Authorization: `Bearer ${managerToken}` } }
      );
      console.log(`‚úÖ Registro do manager exclu√≠do`);
    } catch (error) {
      console.log(`‚ö†Ô∏è N√£o foi poss√≠vel excluir o registro do manager: ${error.message}`);
    }

  } catch (error) {
    console.error('‚ùå ERRO ao testar visualiza√ß√£o de registros pr√≥prios:', 
      error.response ? error.response.data : error.message);
  }
}

// Fun√ß√£o para teste do manager
async function testarFuncionalidadesManager() {
  console.log('\nüöÄ Iniciando teste de visualiza√ß√£o de horas pr√≥prias por Manager');
  
  try {
    // Login como manager (usando as credenciais reais do manager)
    console.log('\nüë§ Autenticando como manager...');
    const responseManager = await axios.post(`${BASE_URL}/mobile-auth`, MANAGER_USER);
    const managerToken = responseManager.data.token;
    const managerUser = responseManager.data.user;
    
    console.log(`‚úÖ Manager autenticado: ${managerUser.name} (${managerUser.role})`);
    console.log(`üìå Manager companyId: ${managerUser.companyId}`);
    
    // Agora chame a fun√ß√£o de teste passando token e user como par√¢metros
    await testManagerOwnTimeEntries(managerToken, managerUser);
    
    console.log('\n‚úÖ Teste de manager conclu√≠do!');
  } catch (error) {
    console.log('‚ùå Falha ao autenticar como manager:', error.message);
    if (error.response) {
      console.log('Resposta:', error.response.data);
    }
  }
}

async function testPeriodAllParameter() {
  console.log('\nüóìÔ∏è Testando par√¢metro period=all');
  let employeeToken = null;
  let employeeUser = null;
  const todayFormatted = getTodayFormatted();
  const pastDateFormatted = getPastDateFormatted();
  const entriesToCleanup = [];

  try {
    console.log('\nüë§ Autenticando como funcion√°rio para teste de per√≠odo...');
    const responseEmployee = await axios.post(`${BASE_URL}/mobile-auth`, EMPLOYEE_USER);
    employeeToken = responseEmployee.data.token;
    employeeUser = responseEmployee.data.user;
    console.log(`‚úÖ Funcion√°rio autenticado para teste de per√≠odo: ${employeeUser.name}`);

    // Criar registro no m√™s atual
    const entryTodayPayload = {
      date: todayFormatted,
      startTime: `${todayFormatted}T09:00:00`,
      endTime: `${todayFormatted}T10:00:00`,
      observation: `Registro period=all (hoje) ${Date.now()}`,
    };
    const entryTodayRes = await axios.post(`${BASE_URL}/mobile-time-entries`, entryTodayPayload, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const entryToday = entryTodayRes.data.timeEntry;
    entriesToCleanup.push(entryToday.id);
    console.log(`‚úÖ Registro criado para hoje: ${entryToday.id}`);

    // Criar registro no m√™s passado
    const entryPastPayload = {
      date: pastDateFormatted,
      startTime: `${pastDateFormatted}T09:00:00`,
      endTime: `${pastDateFormatted}T10:00:00`,
      observation: `Registro period=all (passado) ${Date.now()}`,
    };
    const entryPastRes = await axios.post(`${BASE_URL}/mobile-time-entries`, entryPastPayload, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const entryPast = entryPastRes.data.timeEntry;
    entriesToCleanup.push(entryPast.id);
    console.log(`‚úÖ Registro criado para m√™s passado: ${entryPast.id}`);

    await sleep(RETRY_DELAY); // Dar tempo para os registros serem processados

    // Teste 1: Buscar com period=all
    console.log('\nüîç Testando GET /mobile-time-entries?period=all');
    const allEntriesRes = await axios.get(`${BASE_URL}/mobile-time-entries?period=all`, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const allEntries = allEntriesRes.data.timeEntries || [];
    const foundTodayInAll = allEntries.some(e => e.id === entryToday.id);
    const foundPastInAll = allEntries.some(e => e.id === entryPast.id);

    if (foundTodayInAll && foundPastInAll) {
      console.log(`‚úÖ period=all retornou os registros de hoje e do passado (Total: ${allEntries.length}).`);
    } else {
      console.error('‚ùå Falha no period=all. N√£o encontrou todos os registros esperados.');
      if (!foundTodayInAll) console.log('  - Registro de hoje n√£o encontrado com period=all');
      if (!foundPastInAll) console.log('  - Registro do passado n√£o encontrado com period=all');
    }
    console.log('  Filtros aplicados pela API:', allEntriesRes.data.appliedFilters);
    if(allEntriesRes.data.period.startDate !== null || allEntriesRes.data.period.endDate !== null){
        console.error('‚ùå ERRO: Com period=all, period.startDate e period.endDate deveriam ser null.');
    }

    // Teste 2: Buscar sem period (padr√£o m√™s atual)
    console.log('\nüîç Testando GET /mobile-time-entries (padr√£o m√™s atual)');
    const currentMonthEntriesRes = await axios.get(`${BASE_URL}/mobile-time-entries`, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const currentMonthEntries = currentMonthEntriesRes.data.timeEntries || [];
    const foundTodayInCurrent = currentMonthEntries.some(e => e.id === entryToday.id);
    const foundPastInCurrent = currentMonthEntries.some(e => e.id === entryPast.id);

    if (foundTodayInCurrent && !foundPastInCurrent) {
      console.log(`‚úÖ Padr√£o de m√™s atual funcionou. Retornou ${currentMonthEntries.length} registro(s) (apenas o de hoje).`);
    } else {
      console.error('‚ùå Falha no padr√£o de m√™s atual.');
      if (!foundTodayInCurrent) console.log('  - Registro de hoje n√£o encontrado no padr√£o m√™s atual.');
      if (foundPastInCurrent) console.log('  - Registro do passado FOI encontrado no padr√£o m√™s atual (n√£o deveria).');
    }
    console.log('  Filtros aplicados pela API:', currentMonthEntriesRes.data.appliedFilters);
    if(currentMonthEntriesRes.data.period.startDate === null || currentMonthEntriesRes.data.period.endDate === null){
        console.error('‚ùå ERRO: Sem period=all, period.startDate e period.endDate N√ÉO deveriam ser null.');
    }

  } catch (error) {
    console.error('‚ùå ERRO no teste do par√¢metro period=all:', error.response ? error.response.data : error.message);
  } finally {
    // Limpeza
    console.log('\nüßπ Limpando registros do teste period=all...');
    for (const entryId of entriesToCleanup) {
      try {
        await axios.delete(`${BASE_URL}/mobile-time-entries/${entryId}`, { headers: { Authorization: `Bearer ${employeeToken}` } });
        console.log(`  - Registro ${entryId} exclu√≠do.`);
      } catch (delError) {
        console.warn(`  - Falha ao excluir registro ${entryId}:`, delError.message);
      }
    }
  }
}

async function testIsPaidField() {
  console.log('\nüí∞ Testando campo isPaid nos registros de horas');
  let adminToken = null, employeeToken = null;
  let adminUser = null, employeeUser = null;
  const entryIdsToPay = [];
  const entriesToCleanup = [];
  const todayFormatted = getTodayFormatted();

  try {
    // Autenticar Admin e Funcion√°rio
    console.log('\nüë§ Autenticando Admin e Funcion√°rio para teste isPaid...');
    const resAdmin = await axios.post(`${BASE_URL}/mobile-auth`, ADMIN_USER);
    adminToken = resAdmin.data.token;
    adminUser = resAdmin.data.user;
    console.log(`‚úÖ Admin autenticado: ${adminUser.name}`);

    const resEmployee = await axios.post(`${BASE_URL}/mobile-auth`, EMPLOYEE_USER);
    employeeToken = resEmployee.data.token;
    employeeUser = resEmployee.data.user;
    console.log(`‚úÖ Funcion√°rio autenticado: ${employeeUser.name}`);

    // Criar dois registros como funcion√°rio
    console.log('\n‚è±Ô∏è Funcion√°rio criando registros...');
    const entry1Payload = { date: todayFormatted, startTime: `${todayFormatted}T13:00:00`, endTime: `${todayFormatted}T14:00:00`, observation: `Registro isPaid 1 ${Date.now()}` };
    const entry2Payload = { date: todayFormatted, startTime: `${todayFormatted}T15:00:00`, endTime: `${todayFormatted}T16:00:00`, observation: `Registro isPaid 2 ${Date.now()}` };
    const entry3Payload = { date: todayFormatted, startTime: `${todayFormatted}T17:00:00`, endTime: `${todayFormatted}T18:00:00`, observation: `Registro isPaid 3 (pendente) ${Date.now()}` };

    const resEntry1 = await axios.post(`${BASE_URL}/mobile-time-entries`, entry1Payload, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const entry1 = resEntry1.data.timeEntry;
    entriesToCleanup.push(entry1.id);
    console.log(`  - Registro 1 criado: ${entry1.id}`);

    const resEntry2 = await axios.post(`${BASE_URL}/mobile-time-entries`, entry2Payload, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const entry2 = resEntry2.data.timeEntry;
    entriesToCleanup.push(entry2.id);
    console.log(`  - Registro 2 criado: ${entry2.id}`);
    
    const resEntry3 = await axios.post(`${BASE_URL}/mobile-time-entries`, entry3Payload, { headers: { Authorization: `Bearer ${employeeToken}` } });
    const entry3 = resEntry3.data.timeEntry; // Pendente, n√£o ser√° aprovado
    entriesToCleanup.push(entry3.id);
    console.log(`  - Registro 3 (pendente) criado: ${entry3.id}`);

    await sleep(RETRY_DELAY);

    // Admin aprova os dois primeiros registros
    console.log('\nüëç Admin aprovando registros...');
    await axios.put(`${BASE_URL}/mobile-time-entries/${entry1.id}/approve`, { approved: true }, { headers: { Authorization: `Bearer ${adminToken}` } });
    console.log(`  - Registro ${entry1.id} aprovado.`);
    await axios.put(`${BASE_URL}/mobile-time-entries/${entry2.id}/approve`, { approved: true }, { headers: { Authorization: `Bearer ${adminToken}` } });
    console.log(`  - Registro ${entry2.id} aprovado.`);
    entryIdsToPay.push(entry1.id); // Apenas o entry1 ser√° pago

    await sleep(RETRY_DELAY);

    // Admin cria um pagamento incluindo apenas o entry1
    console.log('\nüí≥ Admin criando pagamento para entry1...');
    const paymentPayload = {
      userId: employeeUser.id,
      amount: 50, // Valor simb√≥lico
      date: todayFormatted,
      paymentMethod: "test_method",
      status: "completed",
      periodStart: todayFormatted,
      periodEnd: todayFormatted,
      timeEntryIds: [entry1.id]
    };
    
    let paymentId = null;
    try {
      const paymentRes = await axios.post(`${BASE_URL}/mobile-payments`, paymentPayload, { headers: { Authorization: `Bearer ${adminToken}` } });
      paymentId = paymentRes.data.payment?.id;
      if (paymentId) {
        console.log(`‚úÖ Pagamento criado com ID: ${paymentId}, incluindo registro ${entry1.id}`);
      } else {
        console.error('‚ùå Falha ao criar pagamento, ID n√£o retornado.', paymentRes.data);
      }
    } catch (paymentError) {
        console.error('‚ùå ERRO CR√çTICO ao criar pagamento:', paymentError.response ? paymentError.response.data : paymentError.message);
        // N√£o continuar se o pagamento falhar, pois o teste de isPaid ficar√° incorreto.
        throw paymentError; 
    }

    await sleep(RETRY_DELAY);

    // Buscar todos os registros do funcion√°rio e verificar isPaid
    console.log('\nüìä Verificando campo isPaid nos registros do funcion√°rio...');
    const timeEntriesRes = await axios.get(`${BASE_URL}/mobile-time-entries?userId=${employeeUser.id}&period=all`, { headers: { Authorization: `Bearer ${adminToken}` } });
    const timeEntries = timeEntriesRes.data.timeEntries || [];

    const foundEntry1 = timeEntries.find(e => e.id === entry1.id);
    const foundEntry2 = timeEntries.find(e => e.id === entry2.id);
    const foundEntry3 = timeEntries.find(e => e.id === entry3.id);

    let success = true;
    if (foundEntry1 && foundEntry1.isPaid === true) {
      console.log(`‚úÖ Registro ${entry1.id} (pago): isPaid = true.`);
    } else {
      console.error(`‚ùå Falha: Registro ${entry1.id} (pago) deveria ter isPaid = true, mas √© ${foundEntry1?.isPaid}. Detalhes:`, foundEntry1);
      success = false;
    }

    if (foundEntry2 && foundEntry2.isPaid === false) {
      console.log(`‚úÖ Registro ${entry2.id} (aprovado, n√£o pago): isPaid = false.`);
    } else {
      console.error(`‚ùå Falha: Registro ${entry2.id} (aprovado, n√£o pago) deveria ter isPaid = false, mas √© ${foundEntry2?.isPaid}. Detalhes:`, foundEntry2);
      success = false;
    }
    
    if (foundEntry3 && foundEntry3.isPaid === false) {
      console.log(`‚úÖ Registro ${entry3.id} (pendente, n√£o pago): isPaid = false.`);
    } else {
      console.error(`‚ùå Falha: Registro ${entry3.id} (pendente, n√£o pago) deveria ter isPaid = false, mas √© ${foundEntry3?.isPaid}. Detalhes:`, foundEntry3);
      success = false;
    }

    if(success) console.log('üéâ Teste isPaid conclu√≠do com sucesso!');
    else console.error('‚ùå Teste isPaid falhou em uma ou mais verifica√ß√µes.');

  } catch (error) {
    console.error('‚ùå ERRO no teste do campo isPaid:', error.response ? error.response.data : error.message);
  } finally {
    // Limpeza
    console.log('\nüßπ Limpando registros do teste isPaid...');
    for (const entryId of entriesToCleanup) {
      try {
        await axios.delete(`${BASE_URL}/mobile-time-entries/${entryId}`, { headers: { Authorization: `Bearer ${employeeToken}` } });
        console.log(`  - Registro ${entryId} exclu√≠do.`);
      } catch (delError) {
        console.warn(`  - Falha ao excluir registro ${entryId}:`, delError.message);
      }
    }
    // TODO: Adicionar limpeza do pagamento criado, se necess√°rio (ex: DELETE /mobile-payments/:paymentId)
  }
}

// Executar todos os testes
async function runAllTests() {
  await testarAprovacaoHorasAdmin().catch(error => console.error('üí£ Erro no testarAprovacaoHorasAdmin:', error.response ? error.response.data : error.message));
  await testarFuncionalidadesManager().catch(error => console.error('üí£ Erro no testarFuncionalidadesManager:', error.response ? error.response.data : error.message));
  await testPeriodAllParameter().catch(error => console.error('üí£ Erro no testPeriodAllParameter:', error.response ? error.response.data : error.message));
  await testIsPaidField().catch(error => console.error('üí£ Erro no testIsPaidField:', error.response ? error.response.data : error.message));
  console.log('\nüèÅ Todos os testes de time-entries conclu√≠dos! üèÅ');
}

runAllTests();